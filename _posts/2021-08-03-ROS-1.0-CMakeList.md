---
title:  "CMakeLists.txt의 기본 내용"
excerpt: "CMakeLists.txt의 내용과 구성, 기능, 작성방법 등에 대해 알아보자"
toc: true
toc_sticky: true

categories:
  - ROS 1.0
tags:
  - ROS 1.0
  - CMakeLists
last_modified_at: 2021-08-03T21:20:00
---

## 0. 참고 문헌
*- [CmakeLists.txt ros wiki page](http://wiki.ros.org/catkin/CMakeLists.txt)*

*- [CMake Main page](https://cmake.org/)*

## 1. CMakeLists.txt란?

해당 페이지는 CmakeLists.txt ros wiki page의 내용을 주로 옮겨왔다.

`CmakeLists.txt`파일은 소프트웨어 패키지 빌드를 위한 CMake 빌드 시스템의 입력 파일이다. CMake와 호환되는 패키지는 하나 이상의 CMakeLists.txt 파일을 가지며, 이 파일을 통해 어떻게 패키지 내의 코드를 빌드하고 어디에 설치할 지를 기술하게 된다.

## 2. CMakeLists.txt의 전체적인 구조와 순서

1. 최소 CMake 버전 요구사항 (cmake_minimum_required)
2. 패키지 이름 (project())
3. 빌드를 위해 필요한 다른 CMake/Catkin 패키지 (find_package())
4. 파이썬 모듈 지원 여부 (catkin_python_setup())
5. 메시지/서비스/액션 생성자 (add_message_files(), add_service_files(), add_action_files())
6. 메시지/서비스/액션 생성 실행 (generate_messages())
7. 패키지 빌드 정보 (catkin_package())
8. 빌드할 라이브러리와 실행파일 (add_library()/add_executable()/target_link_libraries())
9. 테스트 (catkin_add_gtest())
10. 설치 룰 (install())

## 3. CMake 버전
패키지를 빌드하기 위해 최소로 필요한 CMake 버전을 입력한다. ROS 1.0의 catkin에서는 최소 2.8.3 이상을 필요로 한다.
```bash
cmake_minimum_required(VERSION 2.8.3)
```

## 4. Package Name
패키지 명을 project 함수를 통해 전달한다. 현재 패키지의 폴더 명과 동일해야 한다.
```bash
project([PACKAGE_NAME])
```

## 5. 빌드에 필요한 CMake 패키지 찾기
find_package 함수를 이용하여 패키지 빌드를 위해 필요한 다른 의존 패키지들을 입력한다.

ROS 1.0의 경우 catkin 패키지가 필요하므로 항상 catkin 패키지를 추가해야 한다.
```bash
find_package(catkin REQUIRED)
```

또한 COMPONENTS 인자를 통해 해당 패키지에서 가져올 부분을 다음 예시처럼 명시해주어야 한다.
```bash
find_package(catkin REQUIRED COMPONENTS
  gazebo_ros
  roscpp
  std_msgs
  message_generation
  sensor_msgs
  geometry_msgs
  tf
)
```
이렇게 하면, 해당 패키지에 대한 헤더 파일 경로, 라이브러리 정보 등이 `catkin_` 환경 변수에 적용될 것이다. 즉 `catkin_INCLUDE_DIRS` 안에 각 catkin 패키지에 대한 헤더 파일 경로 뿐 아니라, 각 패키지에 대한 환경변수도 생성이 된다. 이렇게 해두면 나중에 편리할 수 있다.

물론 각각의 패키지에 대해서 find_package 함수를 사용할 수 있으며, 각 패키지에 대한 [PACKAGE_NAME]_INCLUDE_DIRS, [PACKAGE_NAME]_LIBRARIES 등과 같이 별도의 환경변수 세트가 생성된다.

그 이외의 catkin 패키지가 아닌 패키지들을 추가적으로 필요한 다른 의존성 패키지들을 추가하면 된다.

## 6. catkin_package()
catkin_package() 는 catkin이 제공하는 CMake 매크로 함수로 catkin 관련 정보를 빌드 시스템에 전달하여 pkg-config와 CMake 파일을 생성하기 위해 필요하다. 이 함수는 반드시 add_library() or add_executable()로 빌드 타겟을 선언하기 전에 호출하여야 하며, 다음의 5 개의 선택가능한 인자를 가진다.

* INCLUDE_DIRS - 피키지를 위한 cflags 등의 include 경로
* LIBRARIES - 프로젝트의 라이브러리 결과물
* CATKIN_DEPENDS - 프로젝트가 의존성을 가진 다른 catkin 프로젝트
* DEPENDS - 프로젝트가 의존성을 가진 Non-catkin CMake 프로젝트
* CFG_EXTRAS - 기타 설정 옵션

## 7. 빌드 타겟 정의
빌드 타겟은 일반적으로 아래 두 가지 방법 중 하나를 선택한다.
* 실행 파일 타겟 - 실행할 수 있는 프로그램 형태
* 라이브러리 타겟 - 빌드나 실행시 실행 파일 타겟이 사용할 라이브러리

### 7.1 타겟 설정
*우선 catkin에서 빌드 타겟의 이름은 어느 폴더에 빌드/설치되느냐와 관계 없이 중복되지 않는 유일한 것이어야 한다. 이는 CMake의 규칙이다.* 타겟의 이름을 변경하고자 할때에는 아래와 같이 set_target_properties() 함수를 사용하면 된다.
```bash
set_target_properties(rviz_image_view
                      PROPERTIES OUTPUT_NAME image_view
                      PREFIX "")
```
이 명령은 타겟의 이름이 rviz_image_view에서 image_view로 변경되어 빌드/설치 결과물에 반영된다.

### 7.2 출력 디렉토리 설정
실행 파일과 라이브러리를 위한 기본 출력 디렉토리가 정해져 있으나 특별한 경우 이를 원하는 대로 수정할 수 있다. 예로 파이썬 바인딩이 필요한 라이브러리의 경우 파이선 import가 가능한 폴더에 위치해야 할 수 있다.
```bash
set_target_properties(python_module_library
  PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${CATKIN_DEVEL_PREFIX}/${CATKIN_PACKAGE_PYTHON_DESTINATION})
```

### 7.3 Include 경로와 Library 경로
타겟을 정의하기 전에 빌드에 필요한 헤더 파일이나 라이브러리 등의 경로에 대한 정보를 기술해 두어야 한다.
* Include 경로 - 코드 빌드를 위해 필요한 헤더 파일의 위치 지정
* Library 경로 - 실행 파일 타겟 빌드를 위해 필요한 라이브러리의 위치 지정

#### 7.3.1 include_directories()
include_directories()의 인자는 앞서 find_package() 호출 시 생성된 *_INCLUDE_DIRS 환경 변수와 추가로 지정한 디렉토리 경로가 반영된다. catkin과 Boost를 사용하는 경우, 아래와 같이 기술하면 된다. 여기서 맨 앞의 include는 패키지 내부의 include 폴더를 나타내며, 해당 경로를 추가해주어야 패키지 내부의 헤더파일들을 추가할 수 있다.
```bash
include_directories(include ${Boost_INCLUDE_DIRS} ${catkin_INCLUDE_DIRS})
```

#### 7.3.2 link_directories()
라이브러리 경로를 추가하기 위해 CMake link_directories() 함수를 사용할 수 있으나, 추천되는 방법은 아니다. 왜냐하면 find_package() 실행 시 모든 catkin과 CMake 패키지를 위한 link 정보를 얻게 되기 때문이다. target_link_libraries()를 이용하여 라이브러리를 링크하면 된다.
```bash
link_directories(~/my_libs)
```

### 7.4 실행 파일 추가
빌드할 대상인 실행 파일을 추가하기 위해 add_executable() 함수를 사용한다.
```bash
add_executable(myProgram src/main.cpp src/some_file.cpp src/another_file.cpp)
```
위 예제는 3 개의 소스 파일(src/main.cpp, src/some_file.cpp, src/another_file.cpp)을 빌드하여 myProgram이라는 이름의 실행 파일을 만들어낸다.

### 7.5 라이브러리 타겟 추가
add_library() 함수를 이용하여 빌드할 라이브러리를 기술한다. 기본적으로 catkin은 공유 라이브러리로 빌드한다.
```bash
add_library(${PROJECT_NAME} ${${PROJECT_NAME}_SRCS})
```

### 7.6 target_link_libraries()
target_link_libraries() 함수로 실행 파일 타겟과 링크될 라이브러리를 지정한다. 일반적으로 add_executable() 또는 add_library() 호출 이후에 위치하며, 만약 `ros is not found` 라는 오류가 확인되면 `${catkin_LIBRARIES}`를 추가한다.

```bash
target_link_libraries(<executableTargetName>, <lib1>, <lib2>, ... <libN>)
```
여기서 `<executableTargetName>`은 add_executable() 또는 add_library() 함수의 첫 번째 인자(executable name or library name)과 같다.

### 7.7 add_dependencies()
빌드하려는 패키지가 타겟하는 의존성 패키지에서 messages/services/actions을 사용한다면, `catkin_EXPORTED_TARGETS`에 대한 의존성을 추가해주어야 한다.(예시에서 some_target은 add_executable()로 설정한 실행 파일 타겟 이름이다)
```bash
add_dependencies(some_target ${catkin_EXPORTED_TARGETS})
```

또한 빌드하려는 패키지가 message/services/actions을 사용한다면 역시 다음과 같이 의존성을 추가해주어야 한다.
```bash
add_dependencies(some_target ${${PROJECT_NAME}_EXPORTED_TARGETS})
```

만약 두 가지의 경우 모두 해당한다면, 다음과 같이 사용하며, 대부분의 ROS 패키지에서는 해당 함수를 사용하게 된다.
```bash
add_dependencies(some_target ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})
```

지속 작성 중 ...